from microbit import *                                              #   Created by: Steven Alexander Staubach
from array import *                                                 #   Project in: Introduction to Engineering (CPE) at MSU Denver
import random,utime                                                 #   Instructor: Ivo Georgiev, Class [CPE-1040-002 38108.201930]
active,bits,counter,pause,start,screen,x,y = False,[],0,850,0,0,0,0 #   Assignment: Create a .py micropython bit conversion program
def bitstatesave():                                                 # bitstatesave:
    if active:                                                      # This function confirms the state selection of a bit under the
        bits.append('1')                                            # cursor, which is toggled with button a. This happens once the
    else:                                                           # b button, which is used to move the cursor forward, is pushed
        bits.append('0')                                            # and will append 1 / 0 to a bit list until 32 bits are stored.
def bitstatetoggle():                                               # bitstatetoggle:
    global active                                                   # This function fetches the current state of the bit, which may
    if display.get_pixel(x,y) == 0:                                 # be active or inactive. pressing a button will then invert the
        active = True                                               # current state, which changes the value which will be saved by
    else:                                                           # bitstatesave and also affects which cursor blink is returned.
        active = False
def bitvaluecreation():                                             # bitvaluecreation:
    global bitstring,bitvalue,bituint,bitsint,bitfloat              # This takes the 32 bits generated by the bit creation process,
    bitstring = ''.join(bits)                                       # then converts the binary string into the 4 values as outlined
    bituint = int(bitstring,2)                                      # in the project objectives. The 4 values are unsigned / signed
    if (bits[0]) == '1':                                            # integers, the float32 interpretation, and 4 ascii characters.
        bits[:] = ['0' if value == '1' else '1' for value in bits]
        sbits = ''.join(bits)
        bitsint = (int(sbits,2)*(-1))-1
    else:
        bitsint = bituint
    #bitfloat = array("i",bits)                                   <-
def cursor():                                                       # cursor:
    cursor = display.set_pixel(x,y,6)                               # A blinking indicator used to inform the user of the bit which
    sleep(50)                                                       # they are currently modifying for the 32 bit creation process,
    if active:                                                      # or of their menu order location during the selection process.
        cursor = display.set_pixel(x,y,3)                           # The cursor function is dependant on bit states being defined.
    else:
        cursor = display.set_pixel(x,y,0)
    sleep(50)
def defaultmovement():                                              # defaultmovement:
    global x,y                                                      # the fundamental movement of the cursor when pressing button b
    if x < 4:                                                       # which keeps the cursor within the 5 by 5 display hard limits.
        x = x+1
    else:
        x,y = 0,y+1
def complexmovement():                                              # complexmovement:
    global x,y,active,screen                                        # Further defines cursor bounds by setting program soft limits.
    if screen == 0:                                                 #   screen 0:
        bitstatesave()                                              #   The first screen. This creation screen defines bits 1 - 25,
        if x == 4 and y == 4:                                       #   then once passed, clears the display and moves to screen 1.
            x,y,screen = 0,0,1
            display.clear()
        else:
            defaultmovement()
    elif screen == 1:                                               #   screen 1:
        bitstatesave()                                              #   The second creation screen, where bits 25 - 32 are defined.
        if x == 1 and y == 1:                                       #   Once defined, values are made and the selection menu opens.
            x,y,screen = 0,0,2
            display.clear()
            bitvaluecreation()
            display.scroll("SELECTION MENU", delay=40)
            sleep(600)
        else:
            defaultmovement()
    elif screen == 2:                                               #   screen 2:
        if y < 3:                                                   #   The third screen has the cursor move down the value options
            y = y+1                                                 #   and also represents the values to be displayed to the user.
        else:
            y = 0
    active = False
while True:                                                         # main loop:
    cursor()                                                        # The program defines the use of the a / b buttons by function;
    if screen <= 1:                                                 # such that the button a is used for selection during the loop,
        while button_a.is_pressed():                                # meanwhile the button b is used for movements within the loop.
            bitstatetoggle()                                        # Further, button b may be held to progress to the next screen.
        if button_b.is_pressed():
            start = utime.ticks_ms()
            while True:
                if not button_b.is_pressed():
                    break
            if utime.ticks_diff(utime.ticks_ms(), start) < pause:
                complexmovement()
            else:
                while screen == 1:
                    complexmovement()
                while screen == 0:
                    complexmovement()
    if screen == 2:                                                 # selection screen:
        if y == 0:                                                  # Screen 2 is the selection screen, where the values of 32 bits
            if counter == 0:                                        # defined by the user will be displayed in different variations
                display.scroll("U-INT", delay=45)                   # as they determine and select between various interpretations.
                counter = 1                                         # The menu displays each value definition and shows its symbol.
            display.show(Image('05105:05105:05105:05105:00550'))
            if button_a.is_pressed():
                display.scroll(bituint, delay=100)
        elif y == 1:
            if counter == 0:
                display.scroll("S-INT", delay=45)
                counter = 1
            display.show(Image('05555:00510:00510:00510:05555'))
            if button_a.is_pressed():
                display.scroll(bitsint, delay=100)
        elif y == 2:
            if counter == 0:
                display.scroll("FLOAT", delay=45)
                counter = 1
            display.show(Image('05555:05100:05550:05100:05100'))
            if button_a.is_pressed():
                display.scroll(bitfloat, delay=100)
        elif y == 3:
            if counter == 0:
                display.scroll("ASCII", delay=45)
                counter = 1
            display.show(Image('00550:05101:05100:05101:00550'))
        if button_b.is_pressed():
            while True:
                if not button_b.is_pressed():
                    break
            complexmovement()
            counter = 0